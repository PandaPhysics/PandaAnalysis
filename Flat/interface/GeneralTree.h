// THIS FILE IS AUTOGENERATED //
#ifndef GeneralTree_H
#define GeneralTree_H
// STARTCUSTOM HEADER

#include "TFile.h"
#include "TTree.h"
#include "TH1D.h"
#include "TLorentzVector.h"
#include "TClonesArray.h"
#include "TString.h"
#include "genericTree.h"
#include <map>

// ENDCUSTOM
#define NJET 20
#define NSUBJET 2
enum class shiftjes { 
  kNominal,
  kJESTotalUp,
  kJESTotalDown,
  kJESAbsoluteMPFBiasUp,
  kJESAbsoluteMPFBiasDown,
  kJESAbsoluteScaleUp,
  kJESAbsoluteScaleDown,
  kJESAbsoluteStatUp,
  kJESAbsoluteStatDown,
  kJESFlavorQCDUp,
  kJESFlavorQCDDown,
  kJESFragmentationUp,
  kJESFragmentationDown,
  kJESPileUpDataMCUp,
  kJESPileUpDataMCDown,
  kJESPileUpPtBBUp,
  kJESPileUpPtBBDown,
  kJESPileUpPtEC1Up,
  kJESPileUpPtEC1Down,
  kJESPileUpPtEC2Up,
  kJESPileUpPtEC2Down,
  kJESPileUpPtRefUp,
  kJESPileUpPtRefDown,
  kJESRelativeFSRUp,
  kJESRelativeFSRDown,
  kJESRelativeJEREC1Up,
  kJESRelativeJEREC1Down,
  kJESRelativePtBBUp,
  kJESRelativePtBBDown,
  kJESRelativePtEC1Up,
  kJESRelativePtEC1Down,
  kJESRelativePtEC2Up,
  kJESRelativePtEC2Down,
  kJESRelativeStatECUp,
  kJESRelativeStatECDown,
  kJESRelativeStatFSRUp,
  kJESRelativeStatFSRDown,
  kJESSinglePionECALUp,
  kJESSinglePionECALDown,
  kJESSinglePionHCALUp,
  kJESSinglePionHCALDown,
  kJESTimePtEtaUp,
  kJESTimePtEtaDown,
  N
}; 
TString jesName(shiftjes);
#define NLEP 4
class GeneralTree : public genericTree {
  public:
    GeneralTree();
    ~GeneralTree();
    void WriteTree(TTree* t);
    void Fill() { treePtr->Fill(); }
    void Reset();    void SetAuxTree(TTree*);
// STARTCUSTOM PUBLIC
    const std::vector<double>& get_betas() const { return betas; }
    const std::vector<int>& get_ibetas() const { return ibetas; }
    const std::vector<int>& get_Ns() const { return Ns; }
    const std::vector<int>& get_orders() const { return orders; }


    // public objects
    struct ECFParams {
      int ibeta;
      int N;
      int order;
      bool operator==(const ECFParams &o) const {
        return ibeta==o.ibeta && N==o.N && order==o.order;
      }
      bool operator<(const ECFParams &o) const {
        return ( N<o.N ||
                (N==o.N && order<o.order) ||
                (N==o.N && order==o.order && ibeta<o.ibeta) );
      }
      bool operator>(const ECFParams &o) const {
        return ! operator<(o);
      }
    };
    enum BTagShift {
      bCent=0,
      bBUp,
      bBDown,
      bMUp,
      bMDown,
      bNShift
    };
    enum BTagJet {
      bJet=0,
      bSubJet,
      bNJet
    };
    enum BTagTags {
      b0=0,
      b1,
      b2,
      bGT0,
      bNTags
    };
    struct BTagParams {
      BTagJet jet;
      BTagTags tag;
      BTagShift shift=(BTagShift)0;
      bool operator==(const BTagParams &o) const {
        return jet==o.jet && tag==o.tag && shift==o.shift;
      }
      bool operator<(const BTagParams &o) const {
        return ( jet<o.jet ||
                 (jet==o.jet && tag<o.tag) ||
                 (jet==o.jet && tag==o.tag && shift<o.shift) );
      }
      bool operator>(const BTagParams &o) const {
        return ! operator<(o);
      }
    };
    enum csvShift {
      csvCent=0,
      csvJESup=7,
      csvJESdown=8,
      csvLFup=9,
      csvLFdown=10,
      csvHFup=11,
      csvHFdown=12,
      csvHFStats1up=13,
      csvHFStats1down=14,
      csvHFStats2up=15,
      csvHFStats2down=16,
      csvLFStats1up=17,
      csvLFStats1down=18,
      csvLFStats2up=19,
      csvLFStats2down=20,
      csvCErr1up=21,
      csvCErr1down=22,
      csvCErr2up=23,
      csvCErr2down=24
    };
    // Array of the CSV/CMVA weight enums that can be looped over
    static const unsigned char nCsvShifts=19;
    csvShift csvShifts[nCsvShifts] = {
      csvCent,
      csvJESup,
      csvJESdown,
      csvLFup,
      csvLFdown,
      csvHFup,
      csvHFdown,
      csvHFStats1up,
      csvHFStats1down,
      csvHFStats2up,
      csvHFStats2down,
      csvLFStats1up,
      csvLFStats1down,
      csvLFStats2up,
      csvLFStats2down,
      csvCErr1up,
      csvCErr1down,
      csvCErr2up,
      csvCErr2down
    };

    // public config
    bool is_monohiggs=false, is_vbf=false, is_fatjet=true, 
         is_leptonic=false, is_photonic=false, is_monotop=false,
         is_hbb=false, is_breg=false, is_adv=false, is_darkg=false, is_vh;
    bool btagWeights=true, useCMVA=false;
    std::map<ECFParams,float*> fjECFNs;
    std::map<BTagParams,float> sf_btags;
    std::map<BTagParams,float> sf_alt_btags;
    std::map<TString,float> signal_weights;
    std::map<csvShift,float> sf_csvWeights;
    static TString csvShiftName(csvShift shift);
// ENDCUSTOM
  private:
// STARTCUSTOM PRIVATE
    const std::vector<double> betas = {0.5, 1.0, 2.0, 4.0};
    const std::vector<int> ibetas = {0,1,2,3};
    const std::vector<int> Ns = {1,2,3,4};
    const std::vector<int> orders = {1,2,3};
    TString fjTreeSize() { return is_vh ? "2" : "1"; }
    std::vector<ECFParams> ecfParams;
    std::vector<BTagParams> btagParams;
    TString makeECFString(ECFParams p) {
      return TString::Format("ECFN_%i_%i_%.2i",p.order,p.N,int(10*betas.at(p.ibeta)));
    }
    TString makeBTagSFString(BTagParams p) {
      TString s = "sf_";
      if (p.jet==bSubJet)
        s += "sj";
      s += "btag";
      switch (p.tag) {
        case b0:
          s += "0"; break;
        case b1:
          s += "1"; break;
        case b2:
          s += "2"; break;
        case bGT0:
          s += "GT0"; break;
        default:
          break;
      }
      if (p.shift==bCent)
        return s;
      switch (p.shift) {
        case bBUp:
          s += "BUp"; break;
        case bBDown:
          s += "BDown"; break;
        case bMUp:
          s += "MUp"; break;
        case bMDown:
          s += "MDown"; break;
        default: break;
      }
      return s;
    }
    TString makeCsvWeightString(csvShift shift, bool isCMVA=false) {
      TString s = isCMVA? "sf_cmvaWeight_" : "sf_csvWeight_";
      switch (shift) {
        case csvCent         :  s += "Cent"         ; break;
        case csvJESup        :  s += "JESup"        ; break;
        case csvJESdown      :  s += "JESdown"      ; break;
        case csvLFup         :  s += "LFup"         ; break;
        case csvLFdown       :  s += "LFdown"       ; break;
        case csvHFup         :  s += "HFup"         ; break;
        case csvHFdown       :  s += "HFdown"       ; break;
        case csvHFStats1up   :  s += "HFStats1up"   ; break;
        case csvHFStats1down :  s += "HFStats1down" ; break;
        case csvHFStats2up   :  s += "HFStats2up"   ; break;
        case csvHFStats2down :  s += "HFStats2down" ; break;
        case csvLFStats1up   :  s += "LFStats1up"   ; break;
        case csvLFStats1down :  s += "LFStats1down" ; break;
        case csvLFStats2up   :  s += "LFStats2up"   ; break;
        case csvLFStats2down :  s += "LFStats2down" ; break;
        case csvCErr1up      :  s += "CErr1up"      ; break;
        case csvCErr1down    :  s += "CErr1down"    ; break;
        case csvCErr2up      :  s += "CErr2up"      ; break;
        case csvCErr2down    :  s += "CErr2down"    ; break;
        default              :  s += "Unknown"      ; break;
      }
      return s;
    }
// ENDCUSTOM
  public:
  int runNumber;
  int lumiNumber;
  ULong64_t eventNumber;
  int isData;
  int npv;
  int pu;
  float rho;
  float mcWeight;
  int trigger;
  int metFilter;
  float filter_maxRecoil;
  int filter_whichRecoil;
  int badECALFilter;
  int category;
  int npdf;
  int nscale;
  float sf_ewkV;
  float sf_qcdV;
  float sf_lepID;
  float sf_lepIso;
  float sf_lepTrack;
  float sf_pho;
  float sf_eleTrig;
  float sf_muTrig;
  float sf_phoTrig;
  float sf_l1Prefire;
  float sf_pu;
  float sf_npv;
  float sf_phoPurity;
  float pfmet[3];
  float pfmetphi[3];
  float pfmetnomu[3];
  float puppimet[3];
  float puppimetphi[3];
  float calomet;
  float calometphi;
  float genmet;
  float genmetphi;
  float genMjj;
  int whichRecoil;
  float puppiUZmag[3];
  float puppiUAmag[3];
  float puppiUZphi[3];
  float puppiUAphi[3];
  float pfUZmag[3];
  float pfUAmag[3];
  float pfUZphi[3];
  float pfUAphi[3];
  float jet12Mass[3];
  float jet12DEta[3];
  float jet12DPhi[3];
  float dphipfmet[3];
  float dphipuppimet[3];
  float dphipuppiUZ[3];
  float dphipuppiUA[3];
  float dphipfUZ[3];
  float dphipfUA[3];
  float genJet1Pt;
  float genJet2Pt;
  float genJet1Eta;
  float genJet2Eta;
  float genJet1Phi;
  float genJet2Phi;
  int nJet[43];
  int nJetMax;
  float jetPt[43][20];
  float jetE[43][20];
  float jetEta[20];
  float jetPhi[20];
  float jetGenPt[20];
  float jetDeepCSV[20];
  float jetDeepQG[20];
  int jetFlav[20];
  int jetIsTight[20];
  int jetIsPU[20];
  int nLoosePhoton;
  int nTightPhoton;
  int loosePho1IsTight;
  float loosePho1Pt;
  float loosePho1Eta;
  float loosePho1Phi;
  float loosePho1r9;
  float loosePho1chIso;
  float loosePho1nhIso;
  float loosePho1phIso;
  float loosePho1hOverE;
  float loosePho1sieie;
  int loosePho1SelBit;
  int nLooseElectron;
  int nLooseMuon;
  int nTightElectron;
  int nTightMuon;
  float muonPt[4];
  float muonEta[4];
  float muonPhi[4];
  int muonSelBit[4];
  int muonPdgId[4];
  float muonD0[4];
  float muonDZ[4];
  int muonIsSoftMuon[4];
  float muonCombIso[4];
  float muonSfLoose[4];
  float muonSfMedium[4];
  float muonSfTight[4];
  float muonSfUnc[4];
  float muonSfReco[4];
  int muTrigMatch[4];
  float electronPt[4];
  float electronEta[4];
  float electronPhi[4];
  int electronSelBit[4];
  int electronPdgId[4];
  int electronPhoMatch[4];
  int electronLPhoMatch[4];
  float electronSfLoose[4];
  float electronSfMedium[4];
  float electronSfTight[4];
  float electronSfUnc[4];
  float electronSfReco[4];
  float electronSfMvaWP90[4];
  float electronSfMvaWP80[4];
  float electronD0[4];
  float electronDZ[4];
  int electronNMissingHits[4];
  int electronTripleCharge[4];
  float electronCombIso[4];
  int eleTrigMatch[4];
  float diLepMass;
  int nTau;
  float tauPt[4];
  float tauEta[4];
  float tauPhi[4];
  float genPho1Pt;
  float genPho1Eta;
  float genPho1Phi;
  int vtxNTrk;
  float vtxScore;
  float vtxChi2;
  float pdfUp;
  float pdfDown;
  float scale[6];
  float lheHT;
  int lheNjets;
};
#endif